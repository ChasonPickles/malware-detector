package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	// "reflect"
	"os"
	// "encoding/csv"
	"encoding/json"
	"time"
	// "bytes"
	// "github.com/gocarina/jsontogo"
)

type feed struct {
	id   string `json:"id"`
	link string `json:"link"`
}

type manyMals struct {
	Mal []struct {
		ID   string `json:"id"`
		Name string `json:"name"`
	} `json:"mal"`
}

type AutoGenerated1 struct {
	Total int `json:"total"`
	From  int `json:"from"`
	Size  int `json:"size"`
	Hits  []struct {
		Title       string    `json:"title"`
		Description string    `json:"description"`
		Link        string    `json:"link"`
		ReportedBy  string    `json:"reported_by"`
		Feed        string    `json:"feed"`
		FeedID      string    `json:"feed_id"`
		Timestamp   time.Time `json:"timestamp"`
		Tags        []string  `json:"tags"`
		Ioc         struct {
			URL      string `json:"url"`
			Hostname string `json:"hostname"`
			IP       string `json:"ip"`
			Md5      string `json:"md5"`
			Sha1     string `json:"sha1"`
		} `json:"ioc"`
		Ipwhois struct {
			Net struct {
				Name   string `json:"name"`
				Handle string `json:"handle"`
			} `json:"net"`
			Org struct {
				Name   string `json:"name"`
				Handle string `json:"handle"`
			} `json:"org"`
		} `json:"ipwhois,omitempty"`
		Location struct {
			Country string `json:"country"`
			City    string `json:"city"`
			Point   struct {
				Lon float64 `json:"lon"`
				Lat float64 `json:"lat"`
			} `json:"point"`
		} `json:"location,omitempty"`
		ID string `json:"id"`
	} `json:"hits"`
	Feed struct {
		ID          string      `json:"id"`
		Name        string      `json:"name"`
		Slug        string      `json:"slug"`
		Link        string      `json:"link"`
		Privacy     string      `json:"privacy"`
		Tags        []string    `json:"tags"`
		Tos         interface{} `json:"tos"`
		Description string      `json:"description"`
		Logo        string      `json:"logo"`
		IsOwner     bool        `json:"is_owner"`
		IsAdmin     bool        `json:"is_admin"`
		IsMember    bool        `json:"is_member"`
		IsGuest     bool        `json:"is_guest"`
		Created     time.Time   `json:"created"`
		Updated     time.Time   `json:"updated"`
	} `json:"feed"`
}

type AutoGenerated struct {
	Total int `json:"total"`
	From  int `json:"from"`
	Size  int `json:"size"`
	Feeds []struct {
		ID          string      `json:"id"`
		Name        string      `json:"name"`
		Slug        string      `json:"slug"`
		Link        string      `json:"link,omitempty"`
		Privacy     string      `json:"privacy"`
		Tags        []string    `json:"tags"`
		Tos         interface{} `json:"tos"`
		Description string      `json:"description"`
		Logo        string      `json:"logo"`
		IsOwner     bool        `json:"is_owner"`
		IsAdmin     bool        `json:"is_admin"`
		IsMember    bool        `json:"is_member"`
		IsGuest     bool        `json:"is_guest"`
		Created     time.Time   `json:"created"`
		Updated     time.Time   `json:"updated"`
	} `json:"feeds"`
}

func main() {
	client := &http.Client{}
	payload := url.Values{}

	req, err := http.NewRequest("GET", "https://api.cymon.io/v2/feeds?size=100&from=0&privacy=public"+payload.Encode(), nil)
	if err != nil {
		fmt.Println(err)
	}
	// fmt.Println(req)
	resp, err := client.Do(req)
	// fmt.Println(resp)
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// var feeds []feed

	// fmt.Println(string(body))

	// fmt.Println(reflect.TypeOf(string(body)))

	// stringWriter := &bytes.Buffer{}
	// enc := jsontogo.NewEncoderWithNameAndTags(stringWriter, "Feed", []string{"json"})
	// if err := enc.Encode([]byte(string(body))); err != nil {
	// 	panic(err)
	// }
	// fmt.Println(string(body))

	var in AutoGenerated

	if err := json.Unmarshal([]byte(string(body)), &in); err != nil {
		panic(err)
	}

	x := len(in.Feeds)
	out := make([]string, x)
	out1 := make([]string, x)

	// fmt.Println(in.Size)
	for index, element := range in.Feeds {
		// fmt.Println(element.ID)
		out[index] = element.ID
		out1[index] = element.Link

		// fmt.Println(index)
		// element is the element from someSlice for where we are
	}

	// fmt.Println(out)
	// fmt.Println(out1)

	// var fin string
	var line string
	f, err := os.Create("/tmp/dat2")
	check(err)
	defer f.Close()

	for index, _ := range out {
		// fmt.Println(out1[index])
		// fmt.Print(out[index])
		url1 := "https://api.cymon.io/v2/ioc/search/feed/" + out[index] + "?from=0&size=100"
		// fmt.Println(url1)

		payload := url.Values{}
	
		req, err := http.NewRequest("GET", url1+payload.Encode(), nil)
		if err != nil {
			fmt.Println(err)
		}
		// fmt.Println(req)
		resp, err := client.Do(req)
		// fmt.Println(resp)
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		// fmt.Println(string(body))

		var in1 AutoGenerated1

		if err := json.Unmarshal([]byte(string(body)), &in1); err != nil {
			panic(err)
		}

		// x := len(in1.Hits)

		for _, element1 := range in1.Hits {
			if len(element1.Ioc.Hostname) == 0 {
				line = "null"
				// fmt.Print("null")
			} else {
				line = element1.Ioc.Hostname
				// fmt.Print(element1.Ioc.Hostname)
			}
			if len(element1.Ioc.Md5) == 0 {
				line = line + ",null"
				// fmt.Print("null")
			} else {
				line = line + "," + element1.Ioc.Md5
				// fmt.Print(element1.Ioc.Md5)
			}
			if len(element1.Ioc.Sha1) == 0 {
				line = line + ",null"
				// fmt.Print("null")
			} else {
				line = line + "," + element1.Ioc.Sha1
				// fmt.Print(element1.Ioc.Sha1)
			}
			// fmt.Print(element1.Ioc.Md5)
			// fmt.Print(element1.Ioc.Sha1)
			// fmt.Println(len(element1.Ioc.URL))
			if len(element1.Ioc.URL) < 5 {
				line = line + ",0"
				// fmt.Println(0)
			} else if element1.Ioc.URL[0:5] == "https" {
				line = line + ",1"
				// fmt.Println(1)
			} else {
				line = line + ",0"
				// fmt.Println(0)
			}
			f.WriteString(line)
			fmt.Print(line + " \n ")

		}

	}

	f.Sync()

	// fmt.Println(body)
	// fmt.Println(in.Size)

	// out := feed{
	// 	id:    in.feeds.id,
	// 	link: in.feeds.link,
	// }

	// bs, err := json.Marshal(out)
	// if err != nil {
	// 	panic(err)
	// }
	//
	// fmt.Println("output:", string(bs))
	// // log.Println(string(body))
	//   // fmt.Println(reflect.TypeOf(string(body)))

}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func checkError(message string, err error) {
	if err != nil {
		log.Fatal(message, err)
	}
}
